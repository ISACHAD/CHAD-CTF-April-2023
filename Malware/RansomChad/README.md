# Ransomchad

Created by Felipe Pineda
Category: Hard

## Story
Help, we found some ransomware on our networks...

**This is not real malware, but we still recommend analyzing it in a VM.**

## Structure

The Challenge/ folder has zip file to be uploaded.

The Other/ folder has a few things necessary if someone needs help with the challenge
- files/ folder have the .encrypted files that are read by the challenge binary. If player accidently deletes their files then you can just give them a these copies. Also rerunning the craftencryptedfiles.c will recreate them.
- main-files/ are the solution outputted (if that's a word) files. You can see the flag is located in mybookreport.png, but instead of text it's actually the image of the text flag.
- RansomChad-Dev/ are files used to craft this challenge. Go nuts with these files if you need to understand the challenge to provide help. Code may be a bit ugly...


## Overview
1. Challenge will print out banner with instructions prompting the player to enter a key. 
    - Key is 8 chars long. Challenge will do nothing and exit if the provided key is not 8 chars long (i.e 1234567 no-op/exit; 12345678 *stuff*; 123456789 no-op/exit).
2. Once an adequate key is given, then it wil try to decrypt/debfuscate the *.encrypted files. Regardless of the correct key or not, the challenge will produce "non-encrypted" files with the files folder. The correct key will produce the right files. See the the files in other/main-files/ folder for reference. The incorrect key will produce corrupted files. 
3. The flag is hidden in mybookreport.png

PLEASE HINT THAT gdb AND SOME SORT OF HEX EXPLORER (ex: xxd) WILL BE SUPER USEFUL IN FIGURING OUT THE CHALLENGE. gdb ALLOWS YOU STEP THROUGH THE CODE. xxd WILL ALLOW YOU TO EXAMINE THE BYTES OF THE ENCRYPTED FILES WHICH IS NECESSARY AS THAT HOW THE FILES WILL BE SEEN IN WHEN gdb DEBUGGING.


## Solution/Walthrough
- First, you'll see that the challenge does a no-op unless the key is 8 chars long. You can find this out through brute-force or cracking open gdb and finding where strlen function is being called with the cmp instruction right after it. The instruction compates the values returned from strlen and the 0x8.
- Stepping through the file you'll see these functions called "stages". They are called exactly four times. Each time it is called, it outputs a file in the files directory. This is the function that needs to be inspected.
- Goin through that function in gdb you will see that it does a bunch of stuff but the gist is that it reads in the file and goes byte by byte doing the below algorithm (using the key provided by the player) to the indivudal byte. After than it writes it back out.  


```
int mod_i = i % input_length:
0x555555555473 <stage+91>       idiv   ebx # eax=i (loop counter), ebx=input_length

rol((contents_buffer[i] + mod_i), mod_i):
0x555555555475 <stage+93>       mov    eax, edx
0x555555555477 <stage+95>       add    al, BYTE PTR [rdi+rsi*1]     # (contents_buffer[i] + mod_i)
0x55555555547a <stage+98>       mov    ecx, edx
0x55555555547c <stage+100>      rol    al, cl                       # al=contents_buffer[i]+mod_i, cl=mod_i

... ^ input[mod_i]:
0x555555555481 <stage+105>      xor    al, BYTE PTR [rbp+rdx*1+0x0] # al=contents_buffer[i]+mod_i, [rbp+rdx*1+0x0]=input[mod_i]

```

```C
contents_size = read_file(filename, &contents_buffer);

for (i=0; i<contents_size; i++){
    int mod_i = i % input_length;
    contents_buffer[i] = rol((contents_buffer[i] + mod_i), mod_i) ^ input[mod_i];
}

... // code here snipped but it pretty much does string setting up for a new filename (i.e new_filename)

write_file(new_filename, contents_buffer, contents_size);

```
- How can someone tell what the key is then? Well we have given files that have a part of the equation.
```
PNG: 89 50 4E 47 0D 0A 1A 0A  === .PNGâ€¦..
GIF: 47 49 46 38 37 6        47 49 46 38 37 61
JPG: FF D8 FF E0 00 10 4A 46 (has more variations) == ......JFIF
PDF: 25 50 44 46 2d  == %PDF-
You could also assume the the file alphabet-lowercase.txt will have "abcdefg...". Turning those chars into hex will give you bytes.
```
PNG Example
```
mybookreport.png.encrypted:  bc 1b 9d 03 92 cc af c1
Desired output (PNG HEADER): 89 50 4E 47 0D 0A 1A 0A
mod: 0 % 8 = 0
add: bc+0 = bc
Rotate Left: bc, 0 = bc
    - 0 here is the mod result
XOR: bc ^ 35 == 89
    - 35 is the first hex value of "5h0wd0wn" (35 68 30 77 64 30 77 6e)
The hard part is attempting bytes until you get what you want which is "89" in this case.
```
[Cyberchef Singular Byte Link](https://gchq.github.io/CyberChef/#recipe=From_Hex('Auto')ADD(%7B'option':'Hex','string':'0'%7D)Rotate_left(0,false)XOR(%7B'option':'Hex','string':'35'%7D,'Standard',false)To_Hex('Space',0)&input=YmM)

Key: `5h0wd0wn`
Flag: `CHAD{W3LL_TH@T_W@SNT_MY_R3PORT}`

*If you get lost just reference the C code. I am providing the code, so you can recompile with `ggdb` and see the code line up with the assembly. You'll be able to step through it with the source code.*

## Hints
1. User input (i.e. key) has a fixed length that must be entered. It isn't long. Start by typing one char first and then keep going. You'll hit it eventually.
2. There's an algorithm in there somewhere that does some mathing. I used the the algorithm XOR+ROR+SUB to generate. How would you reverse that and with what? Next hint says with what :P
3. How can someone tell what the key is then? Well we have given files that have a part of the equation. Files have fixed contants at the beginning. They are called Headers :)

## Notes
- Encrypted files are non-existent or not in the files/ folder. This will cause a seg fault as the challenge reads them at that path. To solve this for the player, either give them copies of the files or tell them to place it in the files/ folder.
- PLEASE MAKE SURE YOU REMIND THEM THAT THEY NEED TO KEEP THE FILE STRUCTURE AS IS WHEN UNZIPPING. MOVING FILES WILL BREAK STUFF. 


